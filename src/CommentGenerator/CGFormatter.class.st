"
I transform output generated by the Identifier class to be the in the correct Format to then generate the correct document.

I know the results of Identifier.
I reformat them to match the correct CRC format.

I collaborate with the Identifier and CommentGenerator Class.
I get info from the Identifier class, format it and pass it on in the correct format to the CommentGenerator class. 

I am using the classes: 
 - CommentGenerator
 - CGIdentifier


I get used by class: 
 - CommentGenerator


I have relevant public methods which are ordere by their usage:
	Externally :
	- formatInstanceVariablesOn: It formats the instance variables I get passed from the CGIdentifier to allow me to write them on a writeStream.
	- formatPublicMethodsOn: It formats the public APIs I get passed from the CGIdentifier to allow me to write them on a writeStream.
	- classStereotypeDescriptionFor: It adds descritiptions of the available class stereotypes for the target class to the write stream.
	

	Internally:
	- initializeIdentifier: It creates the instance of the CGIdentifier that passes me the relevant data


My instance variables are: 
 - identifier
 - mostUsedMethods


My defining keywords are: 
on,format,class,initialize,stereotype,identifier,for,description,variables,instance
"
Class {
	#name : #CGFormatter,
	#superclass : #CommentGenerator,
	#instVars : [
		'identifier',
		'mostUsedMethods'
	],
	#category : #'CommentGenerator-Core'
}

{ #category : #formatters }
CGFormatter >> classStereotypeDescriptionFor: aString [

	"Gets a String representing, and if there is a description for that string it returns a description"

	aString = 'Boundary'
		ifTrue: [ 
			^ 'I function as a communication point between classes. I have a lot of collaborational methods but few controller and fewer factory methods.' ]
		ifFalse: [ 
			aString = 'Commander'
				ifTrue: [ 
				^ 'I encapsulate behavior. I have a lot of mutator methods.' ]
				ifFalse: [ 
					aString = 'Controller'
						ifTrue: [ 
							^ 'I process data from other class and access their functionalities. I have a multitude of controller methods.' ]
						ifFalse: [ 
							aString = 'Data'
								ifTrue: [ 
									^ 'I store data an do not operate on the data . I only contain get and set methods.' ]
								ifFalse: [ 
									aString = 'DataProvider'
										ifTrue: [ 
										^ 'I encapsulate data. I consist mostly  of accessor methods.' ]
										ifFalse: [ 
											aString = 'Degenerate'
												ifTrue: [ 
													^ 'I do nether read nor write data. I consist mostly of degenerate methods.' ]
												ifFalse: [ 
													aString = 'Empty'
														ifTrue: [ 
															^ 'I contain mostly empty or no methods.' ]
														ifFalse: [ 
															aString = 'Entity'
																ifTrue: [ 
																	^ 'I represent an Entity. I have Accessors and Mutators other than get and set, and I have twice as many collaborators compared to noncollaborators.' ]
																ifFalse: [ 
																	aString = 'Factory'
																ifTrue: [ 
																	^ 'I create objects. I am mostly made up of factory methods' ]
																ifFalse: [ 
																	aString = 'Large'
																		ifTrue: [ 
																			^ 'I have a lot of functionality and many lines of code and can maybe be refactored into multiple smaller classes.' ]
																		ifFalse: [ 
																			aString = 'Lazy'
																				ifTrue: [ 
																					^ 'I have very little functionality. I have some get and set methods and maybe a bigger part of degenerate methods.' ]
																				ifFalse: [ 
																					aString = 'MinimalEntity'
																						ifTrue: [ 
																							^ 'I am represent a smaller Entity. I only have get, set and mutator methods' ]
																						ifFalse: [ 
																							aString = 'PureController'
																								ifTrue: [ 
																									^ 'I exclusively work on external objects. All my methods are either factory or controller methods.' ]
																								ifFalse: [ 
																									aString = 'Small'
																										ifTrue: [ 
																											^ 'I only have up to 2 methods.' ]
																										ifFalse: [  ] ] ] ] ] ] ] ] ] ] ] ] ] ]
]

{ #category : #formatters }
CGFormatter >> formatClassStereotypeOn: stream [

	| classStereotypes |
	classStereotypes := identifier classStereotypes.
	classStereotypes do: [ :stereotype | 
		stereotype = '' ifTrue: [ 
			^ stream nextPutAll:
				  'There are no specific classStereotypes that match for me' ] ].
	classStereotypes isNotEmpty ifFalse: [ ^ self ].
	stream nextPutAll: 'I have '.
	classStereotypes size > 1
		ifTrue: [ stream nextPutAll: 'classstereotypes: ' ]
		ifFalse: [ stream nextPutAll: 'classstereotype: ' ].
	classStereotypes do: [ :value | 
		stream
			cr;
			nextPutAll: '- ';
			nextPutAll: value asString;
			cr;
			tab;
			nextPutAll: (self classStereotypeDescriptionFor: value asString) ]
]

{ #category : #formatters }
CGFormatter >> formatClassnameOn: stream [
	"Write the name of the target class on stream"
	stream nextPutAll: 'Classname: '.
	stream nextPutAll: targetClass name.
]

{ #category : #formatters }
CGFormatter >> formatInstanceVariablesOn: stream [

	| instanceVariables |
	instanceVariables := identifier getInstanceVariables.
	instanceVariables size >= 1 ifFalse: [ ^ self ].

	stream
		nextPutAll: 'My instance variables are: ';
		cr.
	instanceVariables do: [ :clv | 
		stream nextPutAll: ' - '.
		stream nextPutAll: clv name.
		stream cr ]
]

{ #category : #formatters }
CGFormatter >> formatKeywordsOn: stream [

	"Write the important keywords of the targetClass on stream"

	| keywords |
	keywords := identifier getRelevantKeyWords.

	stream
		nextPutAll: 'My defining keywords are: ';
		cr.
	stream nextPutAll:
		(',' join: (keywords copyFrom: 1 to: (10 min: keywords size)))
]

{ #category : #formatters }
CGFormatter >> formatPublicMethodsOn: stream [

	"Write the public method of the target class on stream"

	stream
		nextPutAll: 'I have relevant public methods which are ordere by their usage:';
		cr.
	stream tab
		nextPutAll: 'Externally :';
		cr.
	((mostUsedMethods at: 'external') takeFirst: 5) do: [ :methodName | 
		stream
			tab;
			tab.
		stream nextPutAll: ' - '.
		stream nextPutAll: methodName.
		stream cr ].
	stream
		cr;
		tab;
		nextPutAll: 'Internally';
		cr.
	((mostUsedMethods at: 'internal') takeFirst: 5) do: [ :methodName | 
		stream
			tab;
			tab.
		stream nextPutAll: ' - '.
		stream nextPutAll: methodName.
		stream cr ]
]

{ #category : #formatters }
CGFormatter >> formatUsedByOn: stream [

	| usedBy |
	usedBy := identifier getRelevantClassReferences.

	usedBy size > 1
		ifTrue: [ 
			stream
				nextPutAll: 'I get used by classes: ';
				cr ]
		ifFalse: [ 
			stream
				nextPutAll: 'I get used by class: ';
				cr ].
	(usedBy takeFirst: 10) do: [ :cls | 
		stream nextPutAll: ' - '.
		stream nextPutAll: cls name.
		stream cr ].
	usedBy size > 10 ifFalse: [ ^ self ].
	stream
		nextPutAll: '...';
		cr.
	stream nextPutAll: usedBy size asString.
	stream
		nextPutAll: ' Classes in total';
		cr
]

{ #category : #formatters }
CGFormatter >> formatUsersOn: stream [

	"Write the users of the target class on stream"

	| dependentClasses |
	dependentClasses := identifier getDependentClasses.
	dependentClasses size > 1
		ifTrue: [ 
			stream
				nextPutAll: 'I am using the classes: ';
				cr ]
		ifFalse: [ 
			stream
				nextPutAll: 'I am using the class: ';
				cr ].
	((dependentClasses takeFirst: 10) asSet) do: [ :cls | 
		stream nextPutAll: ' - '.
		stream nextPutAll: cls name.
		stream cr ].
	dependentClasses size > 10 ifFalse: [ ^ self ].
	stream
		nextPutAll: '...';
		cr.
	stream nextPutAll: dependentClasses size asString.
	stream
		nextPutAll: ' Classes in total';
		cr
]

{ #category : #initialization }
CGFormatter >> initialize [

	super initialize.
]

{ #category : #initialization }
CGFormatter >> initializeIdentifier [
	
	identifier := CGIdentifier new.
	identifier targetClass: targetClass.
	mostUsedMethods := identifier getMostUsedMethodsForStereotype .
]

{ #category : #accessing }
CGFormatter >> targetClass: aPharoClass [

	super targetClass: aPharoClass.
]
