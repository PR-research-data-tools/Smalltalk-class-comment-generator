"
I transform output generated by the Identifier class to be the in the correct Format to then generate the correct document.

I know the results of Identifier.
I reformat them to match the correct CRC format.

I collaborate with the Identifier and CommentGenerator Class.
I get info from the Identifier class, format it and pass it on in the correct format to the CommentGenerator class. 

I am using the classes: 
 - CommentGenerator
 - CGIdentifier


I get used by class: 
 - CommentGenerator


I have relevant public methods which are ordere by their usage:
	Externally :
	- formatInstanceVariablesOn: It formats the instance variables I get passed from the CGIdentifier to allow me to write them on a writeStream.
	- formatPublicMethodsOn: It formats the public APIs I get passed from the CGIdentifier to allow me to write them on a writeStream.
	- classStereotypeDescriptionFor: It adds descritiptions of the available class stereotypes for the target class to the write stream.
	

	Internally:
	- initializeIdentifier: It creates the instance of the CGIdentifier that passes me the relevant data


My instance variables are: 
 - identifier
 - mostUsedMethods


My defining keywords are: 
on,format,class,initialize,stereotype,identifier,for,description,variables,instance
"
Class {
	#name : #CGFormatter,
	#superclass : #CommentGenerator,
	#instVars : [
		'identifier',
		'mostUsedMethods',
		'descriptionDict'
	],
	#category : #'CommentGenerator-Core'
}

{ #category : #formatters }
CGFormatter >> classStereotypeDescriptionFor: aString [
	^ descriptionDict at: aString ifAbsent: [ '' ]
]

{ #category : #accessing }
CGFormatter >> descriptionDict [
	^ descriptionDict
]

{ #category : #formatters }
CGFormatter >> formatClassStereotypeOn: stream [

	| classStereotypes |
	classStereotypes := identifier classStereotypes.
	classStereotypes do: [ :stereotype | 
		stereotype = '' ifTrue: [ 
			^ stream nextPutAll:
				  'There are no specific class stereotypes that match for me' ] ].
	classStereotypes isNotEmpty ifFalse: [ ^ self ].
	stream nextPutAll: 'I have '.
	classStereotypes size > 1
		ifTrue: [ stream nextPutAll: 'class stereotypes: ' ]
		ifFalse: [ stream nextPutAll: 'class stereotype: ' ].
	classStereotypes do: [ :value | 
		stream
			cr;
			nextPutAll: '- ';
			nextPutAll: value asString;
			cr;
			tab;
			nextPutAll: (self classStereotypeDescriptionFor: value asString) ]
]

{ #category : #formatters }
CGFormatter >> formatClassnameOn: stream [
	"Write the name of the target class on stream"
	stream nextPutAll: 'Classname: '.
	stream nextPutAll: targetClass name.
]

{ #category : #formatters }
CGFormatter >> formatInstanceVariablesOn: stream [

	| instanceVariables |
	instanceVariables := identifier getInstanceVariables.
	instanceVariables size >= 1 ifFalse: [ ^ self ].

	stream
		nextPutAll: 'My instance variables are: ';
		cr.
	instanceVariables do: [ :clv | 
		stream nextPutAll: ' - '.
		stream nextPutAll: clv name.
		stream cr ]
]

{ #category : #formatters }
CGFormatter >> formatKeywordsOn: stream [

	"Write the important keywords of the targetClass on stream"

	| keywords |
	keywords := identifier getRelevantKeyWords.

	stream
		nextPutAll: 'My defining keywords are: ';
		cr.
	stream nextPutAll:
		(', ' join: (keywords copyFrom: 1 to: (10 min: keywords size)))
]

{ #category : #formatters }
CGFormatter >> formatPublicMethodsOn: stream [

	"Write the public method of the target class on stream"

	stream
		nextPutAll: 'I have relevant public methods which are ordere by their usage:';
		cr.
	stream tab
		nextPutAll: 'Externally :';
		cr.
	((mostUsedMethods at: 'external') takeFirst: 5) do: [ :methodName | 
		stream
			tab;
			tab.
		stream nextPutAll: ' - '.
		stream nextPutAll: methodName.
		stream cr ].
	stream
		cr;
		tab;
		nextPutAll: 'Internally';
		cr.
	((mostUsedMethods at: 'internal') takeFirst: 5) do: [ :methodName | 
		stream
			tab;
			tab.
		stream nextPutAll: ' - '.
		stream nextPutAll: methodName.
		stream cr ]
]

{ #category : #formatters }
CGFormatter >> formatUsedByOn: stream [

	| usedBy |
	usedBy := identifier getRelevantClassReferences.

	usedBy size > 1
		ifTrue: [ 
			stream
				nextPutAll: 'I get used by classes: ';
				cr ]
		ifFalse: [ 
			stream
				nextPutAll: 'I get used by class: ';
				cr ].
	(usedBy takeFirst: 10) do: [ :cls | 
		stream nextPutAll: ' - '.
		stream nextPutAll: cls name.
		stream cr ].
	usedBy size > 10 ifFalse: [ ^ self ].
	stream
		nextPutAll: '...';
		cr.
	stream nextPutAll: usedBy size asString.
	stream
		nextPutAll: ' Classes in total';
		cr
]

{ #category : #formatters }
CGFormatter >> formatUsersOn: stream [

	"Write the users of the target class on stream"

	| dependentClasses |
	dependentClasses := identifier getDependentClasses.
	dependentClasses size > 1
		ifTrue: [ 
			stream
				nextPutAll: 'I am using the classes: ';
				cr ]
		ifFalse: [ 
			stream
				nextPutAll: 'I am using the class: ';
				cr ].
	((dependentClasses takeFirst: 10) asSet) do: [ :cls | 
		stream nextPutAll: ' - '.
		stream nextPutAll: cls name.
		stream cr ].
	dependentClasses size > 10 ifFalse: [ ^ self ].
	stream
		nextPutAll: '...';
		cr.
	stream nextPutAll: dependentClasses size asString.
	stream
		nextPutAll: ' Classes in total';
		cr
]

{ #category : #initialization }
CGFormatter >> initialize [
	super initialize.
	self initializeDescriptionDict
]

{ #category : #accessing }
CGFormatter >> initializeDescriptionDict [
	descriptionDict := {'Boundary'
				-> 'I function as a communication point between classes. I have a lot of collaborational methods but few controller and fewer factory methods.'.
			'Commander' -> 'I encapsulate behavior. I have a lot of mutator methods.'.
			'Controller'
				-> 'I process data from other class and access their functionalities. I have a multitude of controller methods.'.
			'Data'
				-> 'I store data an do not operate on the data . I only contain get and set methods.'.
			'DataProvider'
				-> 'I encapsulate data. I consist mostly  of accessor methods.'.
			'Degenerate'
				-> 'I do nether read nor write data. I consist mostly of degenerate methods.'.
			'Empty' -> 'I contain mostly empty or no methods.'.
			'Entity'
				-> 'I represent an Entity. I have Accessors and Mutators other than get and set, and I have twice as many collaborators compared to noncollaborators.'.
			'Factory' -> 'I create objects. I am mostly made up of factory methods'.
			'Large'
				-> 'I have a lot of functionality and many lines of code and can maybe be refactored into multiple smaller classes.'.
			'Lazy'
				-> 'I have very little functionality. I have some get and set methods and maybe a bigger part of degenerate methods.'.
			'MinimalEntity'
				-> 'I am represent a smaller Entity. I only have get, set and mutator methods'.
			'PureController'
				-> 'I exclusively work on external objects. All my methods are either factory or controller methods.'.
			'Small' -> 'I only have up to 2 methods.'} asDictionary
]

{ #category : #initialization }
CGFormatter >> initializeIdentifier [
	
	identifier := CGIdentifier new.
	identifier targetClass: targetClass.
	mostUsedMethods := identifier getMostUsedMethodsForStereotype .
]

{ #category : #accessing }
CGFormatter >> targetClass: aPharoClass [

	super targetClass: aPharoClass.
]
